/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-publish-extra",
factory: function (require) {
var plugin=(()=>{var A=Object.create,T=Object.defineProperty;var D=Object.getOwnPropertyDescriptor;var J=Object.getOwnPropertyNames;var z=Object.getPrototypeOf,H=Object.prototype.hasOwnProperty;var L=e=>T(e,"__esModule",{value:!0});var h=e=>{if(typeof require!="undefined")return require(e);throw new Error('Dynamic require of "'+e+'" is not supported')};var q=(e,t)=>{for(var a in t)T(e,a,{get:t[a],enumerable:!0})},V=(e,t,a)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of J(t))!H.call(e,i)&&i!=="default"&&T(e,i,{get:()=>t[i],enumerable:!(a=D(t,i))||a.enumerable});return e},u=e=>V(L(T(e!=null?A(z(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var $=(e,t,a)=>{if(!t.has(e))throw TypeError("Cannot "+a)};var S=(e,t,a)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,a)};var v=(e,t,a)=>($(e,t,"access private method"),a);var et={};q(et,{default:()=>tt});var B=u(h("@yarnpkg/cli")),o=u(h("@yarnpkg/core")),s=u(h("@yarnpkg/fslib")),f=u(h("@yarnpkg/plugin-npm")),C=u(h("@yarnpkg/plugin-pack")),l=u(h("clipanion")),W,G,I,_,U,F,x=class extends B.BaseCommand{constructor(){super(...arguments);S(this,W);S(this,I);S(this,U);this.access=l.Option.String("--access",{description:"The access for the published package (public or restricted)"});this.tag=l.Option.String("--tag","latest",{description:"The tag on the registry that the package should be attached to"});this.tolerateRepublish=l.Option.Boolean("--tolerate-republish",!1,{description:"Warn and exit when republishing an already existing version of a package"});this.otp=l.Option.String("--otp",{description:"The OTP token to use with the command"});this.source=l.Option.String({name:"source"})}async execute(){let t=await o.Configuration.find(this.context.cwd,this.context.plugins),{project:a}=await o.Project.find(t,this.context.cwd);return await a.restoreInstallState(),(await o.StreamReport.start({configuration:t,stdout:this.context.stdout},async r=>{let d;try{d=(await s.xfs.statPromise(s.npath.toPortablePath(this.source))).isDirectory()}catch(c){throw c.code==="ENOENT"?new l.UsageError("The source parameter has to exist"):c}d?await v(this,W,G).call(this,r,a):await v(this,I,_).call(this,r,a)})).exitCode()}};W=new WeakSet,G=async function(t,a){let i=s.ppath.resolve(s.npath.toPortablePath(this.source)),r=a.tryWorkspaceByCwd(i);r==null&&(r=new o.Workspace(i,{project:a}),await r.setup()),t.reportJson({base:s.npath.fromPortablePath(r.cwd)});let d=await C.packUtils.genPackList(r);for(let g of d)t.reportInfo(null,s.npath.fromPortablePath(g)),t.reportJson({location:s.npath.fromPortablePath(g)});let c=await C.packUtils.genPackStream(r,d),k=await o.miscUtils.bufferStream(c);await v(this,U,F).call(this,t,a,r.manifest,r,k)},I=new WeakSet,_=async function(t,a){let i=await s.xfs.readFilePromise(s.npath.toPortablePath(this.source)),r=await K(i);return await v(this,U,F).call(this,t,a,r,null,i)},U=new WeakSet,F=async function(t,a,i,r,d){var y,P;if(i.private)throw new l.UsageError("Private workspaces cannot be published");if(i.name===null||i.version===null)throw new l.UsageError("Workspaces must have valid names and versions to be published on an external registry");let{name:c,version:k}=i,g=f.npmConfigUtils.getPublishRegistry(i,{configuration:a.configuration});if(this.tolerateRepublish)try{let w=await f.npmHttpUtils.get(f.npmHttpUtils.getIdentUrl(c),{configuration:a.configuration,registry:g,ident:c,jsonResponse:!0});if(!Object.prototype.hasOwnProperty.call(w,"versions"))throw new o.ReportError(o.MessageName.REMOTE_INVALID,'Registry returned invalid data for - missing "versions" field');if(Object.prototype.hasOwnProperty.call(w.versions,k)){t.reportWarning(o.MessageName.UNNAMED,`Registry already knows about version ${k}; skipping.`);return}}catch(w){if(((P=(y=w.originalError)==null?void 0:y.response)==null?void 0:P.statusCode)!==404)throw w}let b=r?await f.npmPublishUtils.getGitHead(r.cwd):void 0,N=await f.npmPublishUtils.makePublishBody(r!=null?r:{manifest:i,project:a},d,{access:this.access,tag:this.tag,registry:g,gitHead:b});await f.npmHttpUtils.put(f.npmHttpUtils.getIdentUrl(c),N,{configuration:a.configuration,registry:g,ident:c,otp:this.otp,jsonResponse:!0}),t.reportInfo(o.MessageName.UNNAMED,"Package archive published")},x.paths=[["npm","publish"]],x.usage=l.Command.Usage({category:"Npm-related commands",description:"publish a folder or tarball to the npm registry",details:'\n      This command will pack the given folder into a fresh archive or take the givne tarball and upload it to the npm registry.\n\n      The package will by default be attached to the `latest` tag on the registry, but this behavior can be overriden by using the `--tag` option.\n      \n      Note that for legacy reasons scoped packages are by default published with an access set to `restricted` (aka "private packages"). This requires you to register for a paid npm plan. In case you simply wish to publish a public scoped package to the registry (for free), just add the `--access public` flag. This behavior can be enabled by default through the `npmPublishAccess` settings.\n\n      Publishing a tarball or folder doesn\'t run any `prepack`, `prepublish`, or `postpack` scripts.\n    ',examples:[["Publish the previously packaged `package.tgz`","yarn npm publish package.tgz"],['Publish the "dist" folder',"yarn npm publish ./dist"]]});var O=x;function K(e){return s.xfs.mktempPromise(async t=>{let a=new s.CwdFS(t);return await o.tgzUtils.extractArchiveTo(e,a,{stripComponents:1}),await o.Manifest.fromFile(o.Manifest.fileName,{baseFs:a})})}var E=u(h("@yarnpkg/cli")),n=u(h("@yarnpkg/core")),p=u(h("@yarnpkg/fslib")),j=u(h("@yarnpkg/plugin-pack")),m=u(h("clipanion")),R=class extends E.BaseCommand{constructor(){super(...arguments);this.installIfNeeded=m.Option.Boolean("--install-if-needed",!1,{description:"Run a preliminary `yarn install` if the package contains build scripts"});this.dryRun=m.Option.Boolean("-n,--dry-run",!1,{description:"Print the file paths without actually generating the package archive"});this.json=m.Option.Boolean("--json",!1,{description:"Format the output as an NDJSON stream"});this.out=m.Option.String("-o,--out",{description:"Create the archive at the specified path"});this.filename=m.Option.String("--filename",{hidden:!0});this.folder=m.Option.String({name:"folder"})}async execute(){var g;let t=await n.Configuration.find(this.context.cwd,this.context.plugins),{project:a}=await n.Project.find(t,this.context.cwd),i=p.ppath.resolve(p.npath.toPortablePath(this.folder)),r=a.tryWorkspaceByCwd(i);if(r==null&&(r=new n.Workspace(i,{project:a}),await r.setup()),!r)throw new E.WorkspaceRequiredError(a.cwd,this.context.cwd);let d=(g=this.out)!=null?g:this.filename,c=p.ppath.resolve(this.context.cwd,typeof d!="undefined"?Q(d,{workspace:r}):"package.tgz");return(await n.StreamReport.start({configuration:t,stdout:this.context.stdout,json:this.json},async b=>{b.reportJson({base:p.npath.fromPortablePath(r.cwd)});let N=await j.packUtils.genPackList(r);for(let y of N)b.reportInfo(null,p.npath.fromPortablePath(y)),b.reportJson({location:p.npath.fromPortablePath(y)});if(!this.dryRun){let y=await j.packUtils.genPackStream(r,N),P=p.xfs.createWriteStream(c);y.pipe(P),await new Promise(w=>{P.on("finish",w)}),b.reportInfo(n.MessageName.UNNAMED,`Package archive generated in ${n.formatUtils.pretty(t,c,n.formatUtils.Type.PATH)}`),b.reportJson({output:p.npath.fromPortablePath(c)})}})).exitCode()}};R.paths=[["pack"]],R.usage=m.Command.Usage({description:"generate a tarball from a folder",details:"\n      This command will turn given folder into a compressed archive suitable for publishing. The archive will by default be stored at the current working directory (`package.tgz`).\n      \n      If the `-o,---out` is set the archive will be created at the specified path. The `%s` and `%v` variables can be used within the path and will be respectively replaced by the package name and version.\n\n      Packaging a folder doesn't run any `prepack` or `postpack` scripts.\n    ",examples:[['Create an archive from the "dist" folder',"yarn pack dist"],['List the files that would be made part of archive of the "output" folder',"yarn pack --dry-run output"],["Name and output the archive in a dedicated folder","yarn pack --out /artifacts/%s-%v.tgz ./dist"]]});var M=R;function Q(e,{workspace:t}){let a=e.replace("%s",X(t)).replace("%v",Y(t));return p.npath.toPortablePath(a)}function X(e){return e.manifest.name!==null?n.structUtils.slugifyIdent(e.manifest.name):"package"}function Y(e){return e.manifest.version!==null?e.manifest.version:"unknown"}var Z={commands:[M,O]},tt=Z;return et;})();
return plugin;
}
};
