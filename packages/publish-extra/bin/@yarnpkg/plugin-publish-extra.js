/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-publish-extra",
factory: function (require) {
"use strict";var plugin=(()=>{var N=Object.defineProperty;var M=Object.getOwnPropertyDescriptor;var A=Object.getOwnPropertyNames;var D=Object.prototype.hasOwnProperty;var J=(e,a,t)=>a in e?N(e,a,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[a]=t;var u=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(a,t)=>(typeof require<"u"?require:a)[t]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')});var z=(e,a)=>{for(var t in a)N(e,t,{get:a[t],enumerable:!0})},H=(e,a,t,o)=>{if(a&&typeof a=="object"||typeof a=="function")for(let r of A(a))!D.call(e,r)&&r!==t&&N(e,r,{get:()=>a[r],enumerable:!(o=M(a,r))||o.enumerable});return e};var L=e=>H(N({},"__esModule",{value:!0}),e);var d=(e,a,t)=>(J(e,typeof a!="symbol"?a+"":a,t),t),q=(e,a,t)=>{if(!a.has(e))throw TypeError("Cannot "+t)};var T=(e,a,t)=>{if(a.has(e))throw TypeError("Cannot add the same private member more than once");a instanceof WeakSet?a.add(e):a.set(e,t)};var x=(e,a,t)=>(q(e,a,"access private method"),t);var X={};z(X,{default:()=>Q});var B=u("@yarnpkg/cli"),i=u("@yarnpkg/core"),n=u("@yarnpkg/fslib"),m=u("@yarnpkg/plugin-npm"),E=u("@yarnpkg/plugin-pack"),l=u("clipanion");var S,F,W,O,U,C,k=class extends B.BaseCommand{constructor(){super(...arguments);T(this,S);T(this,W);T(this,U);d(this,"access",l.Option.String("--access",{description:"The access for the published package (public or restricted)"}));d(this,"tag",l.Option.String("--tag","latest",{description:"The tag on the registry that the package should be attached to"}));d(this,"tolerateRepublish",l.Option.Boolean("--tolerate-republish",!1,{description:"Warn and exit when republishing an already existing version of a package"}));d(this,"otp",l.Option.String("--otp",{description:"The OTP token to use with the command"}));d(this,"source",l.Option.String({name:"source"}))}async execute(){let t=await i.Configuration.find(this.context.cwd,this.context.plugins),{project:o}=await i.Project.find(t,this.context.cwd);return await o.restoreInstallState(),(await i.StreamReport.start({configuration:t,stdout:this.context.stdout},async s=>{let h;try{h=(await n.xfs.statPromise(n.npath.toPortablePath(this.source))).isDirectory()}catch(f){throw f.code==="ENOENT"?new l.UsageError("The source parameter has to exist"):f}h?await x(this,S,F).call(this,s,o):await x(this,W,O).call(this,s,o)})).exitCode()}};S=new WeakSet,F=async function(t,o){let r=n.ppath.resolve(n.npath.toPortablePath(this.source)),s=o.tryWorkspaceByCwd(r);s==null&&(s=new i.Workspace(r,{project:o}),await s.setup()),t.reportJson({base:n.npath.fromPortablePath(s.cwd)});let h=await E.packUtils.genPackList(s);for(let b of h)t.reportInfo(null,n.npath.fromPortablePath(b)),t.reportJson({location:n.npath.fromPortablePath(b)});let f=await E.packUtils.genPackStream(s,h),g=await i.miscUtils.bufferStream(f);await x(this,U,C).call(this,t,o,s.manifest,s,g)},W=new WeakSet,O=async function(t,o){let r=await n.xfs.readFilePromise(n.npath.toPortablePath(this.source)),s=await V(r);return await x(this,U,C).call(this,t,o,s,null,r)},U=new WeakSet,C=async function(t,o,r,s,h){if(r.private)throw new l.UsageError("Private workspaces cannot be published");if(r.name===null||r.version===null)throw new l.UsageError("Workspaces must have valid names and versions to be published on an external registry");let{name:f,version:g}=r,b=m.npmConfigUtils.getPublishRegistry(r,{configuration:o.configuration});if(this.tolerateRepublish)try{let y=await m.npmHttpUtils.get(m.npmHttpUtils.getIdentUrl(f),{configuration:o.configuration,registry:b,ident:f,jsonResponse:!0});if(!Object.prototype.hasOwnProperty.call(y,"versions"))throw new i.ReportError(i.MessageName.REMOTE_INVALID,'Registry returned invalid data for - missing "versions" field');if(Object.prototype.hasOwnProperty.call(y.versions,g)){t.reportWarning(i.MessageName.UNNAMED,`Registry already knows about version ${g}; skipping.`);return}}catch(y){if(y.originalError?.response?.statusCode!==404)throw y}let v=s?await m.npmPublishUtils.getGitHead(s.cwd):void 0,R=await m.npmPublishUtils.makePublishBody(s??{manifest:r,project:o},h,{access:this.access,tag:this.tag,registry:b,gitHead:v});await m.npmHttpUtils.put(m.npmHttpUtils.getIdentUrl(f),R,{configuration:o.configuration,registry:b,ident:f,otp:this.otp,jsonResponse:!0}),t.reportInfo(i.MessageName.UNNAMED,"Package archive published")},d(k,"paths",[["npm","publish"]]),d(k,"usage",l.Command.Usage({category:"Npm-related commands",description:"publish a folder or tarball to the npm registry",details:'\n      This command will pack the given folder into a fresh archive or take the givne tarball and upload it to the npm registry.\n\n      The package will by default be attached to the `latest` tag on the registry, but this behavior can be overriden by using the `--tag` option.\n      \n      Note that for legacy reasons scoped packages are by default published with an access set to `restricted` (aka "private packages"). This requires you to register for a paid npm plan. In case you simply wish to publish a public scoped package to the registry (for free), just add the `--access public` flag. This behavior can be enabled by default through the `npmPublishAccess` settings.\n\n      Publishing a tarball or folder doesn\'t run any `prepack`, `prepublish`, or `postpack` scripts.\n    ',examples:[["Publish the previously packaged `package.tgz`","yarn npm publish package.tgz"],['Publish the "dist" folder',"yarn npm publish ./dist"]]}));function V(e){return n.xfs.mktempPromise(async a=>{let t=new n.CwdFS(a);return await i.tgzUtils.extractArchiveTo(e,t,{stripComponents:1}),await i.Manifest.fromFile(i.Manifest.fileName,{baseFs:t})})}var I=u("@yarnpkg/cli"),c=u("@yarnpkg/core"),p=u("@yarnpkg/fslib"),j=u("@yarnpkg/plugin-pack"),w=u("clipanion");var P=class extends I.BaseCommand{installIfNeeded=w.Option.Boolean("--install-if-needed",!1,{description:"Run a preliminary `yarn install` if the package contains build scripts"});dryRun=w.Option.Boolean("-n,--dry-run",!1,{description:"Print the file paths without actually generating the package archive"});json=w.Option.Boolean("--json",!1,{description:"Format the output as an NDJSON stream"});out=w.Option.String("-o,--out",{description:"Create the archive at the specified path"});filename=w.Option.String("--filename",{hidden:!0});folder=w.Option.String({name:"folder"});async execute(){let a=await c.Configuration.find(this.context.cwd,this.context.plugins),{project:t}=await c.Project.find(a,this.context.cwd),o=p.ppath.resolve(p.npath.toPortablePath(this.folder)),r=t.tryWorkspaceByCwd(o);if(r==null&&(r=new c.Workspace(o,{project:t}),await r.setup()),!r)throw new I.WorkspaceRequiredError(t.cwd,this.context.cwd);let s=this.out??this.filename,h=p.ppath.resolve(this.context.cwd,typeof s<"u"?$(s,r):"package.tgz");return(await c.StreamReport.start({configuration:a,stdout:this.context.stdout,json:this.json},async g=>{g.reportJson({base:p.npath.fromPortablePath(r.cwd)});let b=await j.packUtils.genPackList(r);for(let v of b)g.reportInfo(null,p.npath.fromPortablePath(v)),g.reportJson({location:p.npath.fromPortablePath(v)});if(!this.dryRun){let v=await j.packUtils.genPackStream(r,b),R=p.xfs.createWriteStream(h);v.pipe(R),await new Promise(y=>{R.on("finish",y)}),g.reportInfo(c.MessageName.UNNAMED,`Package archive generated in ${c.formatUtils.pretty(a,h,c.formatUtils.Type.PATH)}`),g.reportJson({output:p.npath.fromPortablePath(h)})}})).exitCode()}};d(P,"paths",[["pack"]]),d(P,"usage",w.Command.Usage({description:"generate a tarball from a folder",details:"\n      This command will turn given folder into a compressed archive suitable for publishing. The archive will by default be stored at the current working directory (`package.tgz`).\n      \n      If the `-o,---out` is set the archive will be created at the specified path. The `%s` and `%v` variables can be used within the path and will be respectively replaced by the package name and version.\n\n      Packaging a folder doesn't run any `prepack` or `postpack` scripts.\n    ",examples:[['Create an archive from the "dist" folder',"yarn pack dist"],['List the files that would be made part of archive of the "output" folder',"yarn pack --dry-run output"],["Name and output the archive in a dedicated folder","yarn pack --out /artifacts/%s-%v.tgz ./dist"]]}));function $(e,a){let t=e.replace("%s",G(a)).replace("%v",_(a));return p.npath.toPortablePath(t)}function G(e){return e.manifest.name!==null?c.structUtils.slugifyIdent(e.manifest.name):"package"}function _(e){return e.manifest.version!==null?e.manifest.version:"unknown"}var K={commands:[P,k]},Q=K;return L(X);})();
return plugin;
}
};
